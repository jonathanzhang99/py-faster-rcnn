# --------------------------------------------------
# Gyrfalcontech Faster RCNN
#
# Runs one network solely as Region Proposer and
# and replaces the ROIs generated by the full
# network with the ROIs from the Region Proposer.
# Used to test the robustness of classifier against
# ROIs genereated from different resolution quality
# 
# Author: Jonathan Zhang, 2017
# --------------------------------------------------

import _init_paths
import caffe
import numpy as np
import argparse
import sys
import cv2

from caffe_utils import preprocess_img
from caffe_utils import setup_net_inputs, process_net_outputs
from fast_rcnn.test import im_list_to_blob, vis_detections
from fast_rcnn.config import cfg, get_output_dir
from fast_rcnn.nms_wrapper import nms
from datasets.factory import get_imdb
from utils.timer import Timer


def parse_args():
    parser = argparse.ArgumentParser(description="test roi generation")
    parser.add_argument('--def_roi', dest='pt_roi',
                        help='prototxt defining the roi network')
    parser.add_argument('--def_cls', dest='pt_cls',
                        help='prototxt defining the classification network')
    parser.add_argument('--net_roi', dest='net_roi',
                        help='network for roi generation')
    parser.add_argument('--net_cls', dest='net_cls',
                        help='network for classification')
    parser.add_argument('--imdb', dest='imdb', default='voc_2007_test',
                        help='image dataset')
    parser.add_argument('--lo_res_first', dest='lo_res', action='store_true',
                        help='set true to generate rois from 224 image')
    parser.add_argument('--vis', dest='vis', action='store_true',
                        help="set true to generate visible debugging")

    if len(sys.argv) == 1:
        parser.print_help()
        sys.exit(1)

    args = parser.parse_args()
    return args


def get_rois(net, im, scale):
    '''Retrieves ROIs from a network

    net: caffe.Net instance
    im: input image
    scale: tuple(target_size, max_size)
    '''
    net_img, im_scale = preprocess_img(im, scale[0], scale[1])
    img_blob = im_list_to_blob([net_img])
    kwargs = setup_net_inputs(net, img_blob, im_scale)
    blobs_out = net.forward(end='proposal', **kwargs)

    # transform rois into original image space
    rois = blobs_out['rois'] / im_scale
    conv5_3 = net.blobs['conv5_3']
    # print conv5_3.data.shape
    # print rois[0]
    return rois, conv5_3


def classify_rois(net, im, scale, rois, feature_maps=None):
    '''Inserts ROIs generated from Region Proposer network directly into faster
    rcnn network, replacing the normally generated ROIs. Returns scores and 
    bounding boxes

    net: caffe.Net instance
    im: input image
    scale: tuple(target_size, max_size)
    rois: list of rois from Region Proposer
    '''
    net_img, im_scale = preprocess_img(im, scale[0], scale[1])
    img_blob = im_list_to_blob([net_img])
    kwargs = setup_net_inputs(net, img_blob, im_scale)

    # rois must be same scale as transformed images
    rois *= im_scale

    net.forward(end='proposal', **kwargs)

    net.blobs['rois'].reshape(*(rois.shape))
    net.blobs['rois'].data[...] = rois.astype(np.float32, copy=False)

    # allow for direct testing of different resolution feature maps
    if feature_maps:
        net.blobs['conv5_3'].reshape(*(feature_maps.shape))
        net.blobs['conv5_3'].data[...] = feature_maps.astype(np.float32,
                                                             copy=False)
    blobs_out = net.forward(start='roi_pool5')
    scores, boxes, _ = process_net_outputs(net, blobs_out, net_img.shape)

    boxes /= im_scale

    return scores, boxes


def run_roi_test(roi_net, cls_net, imdb, lo_res=None, max_per_image=100,
                 thresh=0.05):
    num_images = len(imdb.image_index)
    all_boxes = [[[] for _ in xrange(num_images)]
                 for _ in xrange(imdb.num_classes)]
    output_dir = get_output_dir(imdb, None)

    scales = [(600, 1000), (224, 224)]
    pixel_means = [np.asarray([[[102.9801, 115.9465, 122.7717]]]),
                   np.asarray([[[0, 0, 0]]])]
    if lo_res:
        scales = scales[::-1]
        pixel_means = pixel_means[::-1]
    print scales
    for k in xrange(num_images):
        im = cv2.imread(imdb.image_path_at(k))
        _t = {"stage1": Timer(), "stage2": Timer()}

        _t['stage1'].tic()
        cfg.PIXEL_MEANS = pixel_means[0]
        rois, feature_maps = get_rois(roi_net, im, scales[0])
        _t['stage1'].toc()

        _t['stage2'].tic()
        cfg.PIXEL_MEANS = pixel_means[1]
        scores, boxes = classify_rois(cls_net, im, scales[1], rois,
                                      feature_maps)
        _t['stage2'].toc()

        for j in xrange(1, imdb.num_classes):
            inds = np.where(scores[:, j] > thresh)[0]
            cls_scores = scores[inds, j]
            cls_boxes = boxes[inds, j * 4:(j + 1) * 4]
            cls_dets = np.hstack((cls_boxes, cls_scores[:, np.newaxis])) \
                .astype(np.float32, copy=False)
            keep = nms(cls_dets, cfg.TEST.NMS)
            cls_dets = cls_dets[keep, :]
            if args.vis:
                vis_detections(im, imdb.classes[j], cls_dets)
            all_boxes[j][k] = cls_dets

        # Limit to max_per_image detections *over all classes*
        if max_per_image > 0:
            image_scores = np.hstack([all_boxes[j][k][:, -1]
                                      for j in xrange(1, imdb.num_classes)])
            if len(image_scores) > max_per_image:
                image_thresh = np.sort(image_scores)[-max_per_image]
                for j in xrange(1, imdb.num_classes):
                    keep = np.where(all_boxes[j][k][:, -1] >= image_thresh)[0]
                    all_boxes[j][k] = all_boxes[j][k][keep, :]

        print "{}/{} {:.3f}s {:.3f}s".format(k + 1, num_images,
                                                 _t["stage1"].average_time,
                                                 _t["stage2"].average_time)
    print 'Evaluating detections'
    imdb.evaluate_detections(all_boxes, output_dir)


if __name__ == "__main__":
    args = parse_args()

    caffe.set_mode_gpu()
    caffe.set_device(0)

    cls_net = caffe.Net(args.pt_cls, caffe.TEST, weights=args.net_cls)
    roi_net = caffe.Net(args.pt_roi, caffe.TEST, weights=args.net_roi)

    imdb = get_imdb(args.imdb)

    run_roi_test(roi_net, cls_net, imdb, args.lo_res)
